<!DOCTYPE html>
<html lang="ko">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1748676401736913"
     crossorigin="anonymous"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Arcade — 간단한 미니게임</title>
  <style>
    :root { --bg:#0f1226; --card:rgba(255,255,255,.06); --card2:rgba(255,255,255,.12); --text:#e6e7ef; --muted:#aeb2c6; --accent:#7c5cff; --accent2:#4de1c1; --danger:#ff5c7a; --ok:#39d98a; --shadow:0 10px 40px rgba(0,0,0,.35); --radius:18px; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Helvetica Neue", Helvetica, sans-serif; background: var(--bg); color:var(--text); display:flex; flex-direction:column; gap:24px}
    header{padding:32px 20px 0; max-width:1100px; margin:0 auto; width:100%}
    .title{display:flex; align-items:center; gap:14px; flex-wrap:wrap}
    .logo{width:42px; height:42px; border-radius:12px; background:linear-gradient(135deg,var(--accent),var(--accent2)); box-shadow: var(--shadow); display:grid; place-items:center; font-weight:800}
    h1{font-size: clamp(22px, 3.3vw, 36px); margin:0}
    .subtitle{color:var(--muted); margin-top:6px}

    main{max-width:1100px; width:100%; margin:0 auto; padding:0 20px 40px}
    .tabs{display:flex; gap:10px; flex-wrap:wrap}
    .tab-btn{padding:12px 16px; border-radius:999px; background:var(--card); color:var(--text); border:1px solid rgba(255,255,255,.08); cursor:pointer; transition:.2s transform ease, .2s background; backdrop-filter: blur(8px)}
    .tab-btn:hover{transform:translateY(-2px); background:var(--card2)}
    .tab-btn.active{background:linear-gradient(135deg, rgba(124,92,255,.35), rgba(77,225,193,.28)); border-color:rgba(255,255,255,.2)}

    .grid{display:grid; grid-template-columns: 1fr; gap:20px; margin-top:18px}
    .card{background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); padding:18px; box-shadow: var(--shadow)}
    .card h2{margin:4px 0 12px; font-size:20px}
    .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .btn{padding:10px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.1); background:var(--card2); color:var(--text); cursor:pointer; transition:.2s}
    .btn.acc{background:linear-gradient(135deg,var(--accent),var(--accent2)); border:none; font-weight:700}
    .stat{padding:10px 12px; border-radius:12px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12)}
    select{background:var(--card2); color:var(--text); border-radius:10px; border:1px solid rgba(255,255,255,.12); padding:8px 10px}

    /* Reaction */
    .reactor{height:200px; border-radius:14px; display:grid; place-items:center; font-size:24px; font-weight:700; user-select:none}
    .reactor.wait{background:#2a2e57}
    .reactor.ready{background:#ff6b6b}
    .reactor.go{background:#2ecc71}

    /* Tic Tac Toe */
    .board-wrap{position:relative; width:240px; margin:12px auto}
    .board{display:grid; grid-template-columns: repeat(3,1fr); gap:6px}
    .cell{aspect-ratio:1/1; display:flex; justify-content:center; align-items:center; font-size:42px; background:var(--card2); cursor:pointer; border-radius:10px}
    .overlay{position:absolute; inset:0; pointer-events:none}

    /* Omok */
    .omok-wrap{display:flex; flex-direction:column; gap:10px; align-items:center}
    .omok-frame{position:relative}
    .omok-board{display:grid; grid-template-columns: repeat(15, 1fr); width:540px; max-width:95vw; margin:auto; background:#e0c68d; border:2px solid #333}
    .omok-cell{aspect-ratio:1/1; border:1px solid #555; position:relative; cursor:pointer}
    .stone{width:80%; height:80%; border-radius:50%; position:absolute; top:10%; left:10%}
    .black{background:#000}
    .white{background:#fff; border:1px solid #000}

    footer{text-align:center; color:var(--muted); padding:20px}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="logo">🎮</div>
      <div>
        <h1>Mini Arcade</h1>
        <div class="subtitle">반응속도 · 틱택토(AI) · 오목(AI)</div>
      </div>
    </div>
  </header>
  <main>
    <div class="tabs">
      <button class="tab-btn active" data-tab="reaction">⚡ 반응속도</button>
      <button class="tab-btn" data-tab="tictactoe">❌⭕ 틱택토</button>
      <button class="tab-btn" data-tab="omok">⚫⚪ 오목</button>
    </div>

    <section class="grid tab" id="reaction" style="display:grid">
      <div class="card">
        <h2>⚡ 반응속도 테스트</h2>
        <div id="reactor" class="reactor wait">클릭해서 시작</div>
        <div class="row" style="margin-top:12px">
          <div class="stat">최근 기록: <strong id="rt-last">–</strong> ms</div>
          <div class="stat">최고 기록: <strong id="rt-best">–</strong> ms</div>
        </div>
      </div>
    </section>

    <section class="grid tab" id="tictactoe" style="display:none">
      <div class="card">
        <h2>❌⭕ 틱택토</h2>
        <div class="row">
          <label>상대: 
            <select id="ttt-opponent">
              <option value="ai">AI</option>
              <option value="human">2인</option>
            </select>
          </label>
          <label>선/후: 
            <select id="ttt-first">
              <option value="X">선공 (X)</option>
              <option value="O">후공 (O)</option>
            </select>
          </label>
          <button id="ttt-reset" class="btn">다시 시작</button>
        </div>
        <div class="board-wrap" id="ttt-wrap">
          <svg class="overlay" id="ttt-line"></svg>
          <div class="board" id="ttt-board"></div>
        </div>
        <p id="ttt-status" style="text-align:center; margin-top:10px"></p>
      </div>
    </section>

    <section class="grid tab" id="omok" style="display:none">
      <div class="card">
        <h2>⚫⚪ 오목 (15×15)</h2>
        <div class="row">
          <label>상대: 
            <select id="omok-opponent">
              <option value="ai">AI</option>
              <option value="human">2인</option>
            </select>
          </label>
          <label>선/후: 
            <select id="omok-first">
              <option value="black">선(흑)</option>
              <option value="white">후(백)</option>
            </select>
          </label>
          <button id="omok-reset" class="btn">다시 시작</button>
        </div>
        <div class="omok-wrap">
          <div class="omok-frame" id="omok-frame">
            <svg class="overlay" id="omok-line"></svg>
            <div class="omok-board" id="omok-board"></div>
          </div>
          <p id="omok-status"></p>
        </div>
      </div>
    </section>
  </main>
  <footer>Mini Arcade — 제작자 : mtai_tfcs</footer>

  <script>
    // ===== Utils: tabs & audio beeps =====
    const tabs=document.querySelectorAll('.tab-btn');
    const sections=document.querySelectorAll('.tab');
    tabs.forEach(btn=>btn.addEventListener('click',()=>{ tabs.forEach(b=>b.classList.remove('active')); btn.classList.add('active'); sections.forEach(s=>s.style.display=(s.id===btn.dataset.tab)?'grid':'none'); }));

    // Simple WebAudio beeps (works after first user interaction)
    let AC; function ensureAC(){ if(!AC){ AC=new (window.AudioContext||window.webkitAudioContext)(); } if(AC.state==='suspended') AC.resume(); }
    function beep(freq=600, dur=0.08, type='sine', vol=0.05){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(AC.destination); const now=AC.currentTime; o.start(now); o.stop(now+dur); }
    window.addEventListener('pointerdown', ensureAC, { once:true });

    // ===== Reaction game =====
    (function(){
      const box=document.getElementById('reactor');
      const lastEl=document.getElementById('rt-last');
      const bestEl=document.getElementById('rt-best');
      let state='idle',timer,startTime,best=localStorage.getItem('rt-best'); if(best) bestEl.textContent=best;
      function setState(n){ state=n; box.className='reactor '+n; if(n==='wait'){ box.textContent='클릭해서 시작'; } if(n==='ready'){ box.textContent='초록색 기다리기'; } if(n==='go'){ box.textContent='지금 클릭!'; startTime=performance.now(); } }
      setState('wait');
      box.addEventListener('click',()=>{ ensureAC(); if(state==='wait'){ setState('ready'); timer=setTimeout(()=>{ setState('go'); beep(880,0.05,'square'); },800+Math.random()*2000);} else if(state==='ready'){ clearTimeout(timer); setState('wait'); box.textContent='너무 빨라요!'; beep(220,0.06,'sawtooth'); } else if(state==='go'){ const rt=Math.round(performance.now()-startTime); lastEl.textContent=rt; if(!best||rt<best){best=rt;localStorage.setItem('rt-best',rt);} bestEl.textContent=best; beep(660,0.05,'triangle'); setState('wait'); } });
    })();

    // ===== Tic Tac Toe (AI, 1s delay, win line) =====
    (function(){
      const boardEl=document.getElementById('ttt-board');
      const wrap=document.getElementById('ttt-wrap');
      const lineSvg=document.getElementById('ttt-line');
      const status=document.getElementById('ttt-status');
      const reset=document.getElementById('ttt-reset');
      const selOpp=document.getElementById('ttt-opponent');
      const selFirst=document.getElementById('ttt-first');
      let cells=[],board,turn,gameover=false, human='X', ai='O', aiTimer=null;

      function sizeOverlay(){ const r=wrap.getBoundingClientRect(); lineSvg.setAttribute('width', r.width); lineSvg.setAttribute('height', r.height); lineSvg.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`); }
      window.addEventListener('resize', sizeOverlay);

      function clearLine(){ lineSvg.innerHTML=''; }
      function drawLine(a,b){ sizeOverlay(); const ca=centerOf(a), cb=centerOf(b); const line=document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1',ca.x); line.setAttribute('y1',ca.y); line.setAttribute('x2',cb.x); line.setAttribute('y2',cb.y); line.setAttribute('stroke','#4de1c1'); line.setAttribute('stroke-width','6'); line.setAttribute('stroke-linecap','round'); lineSvg.appendChild(line); }
      function centerOf(idx){ const el=cells[idx]; const er=el.getBoundingClientRect(); const wr=wrap.getBoundingClientRect(); return { x: er.left - wr.left + er.width/2, y: er.top - wr.top + er.height/2 } }

      function init(){ clearTimeout(aiTimer); lineSvg.innerHTML=''; board=['','','','','','','','','']; boardEl.innerHTML=''; cells=[]; gameover=false; human = selFirst.value; ai = (human==='X')?'O':'X'; turn='X'; status.textContent='';
        for(let i=0;i<9;i++){ const c=document.createElement('div'); c.className='cell'; c.addEventListener('click',()=>move(i)); boardEl.appendChild(c); cells.push(c);}        
        sizeOverlay(); updateStatus(); if(selOpp.value==='ai' && human==='O') scheduleAI(); }
      function updateStatus(){ if(gameover) return; status.textContent = (selOpp.value==='ai') ? `${turn===human? '내 차례': 'AI 차례'}` : `${turn} 차례`; }
      function move(i){ if(gameover||board[i]) return; if(selOpp.value==='ai' && turn!==human) return; ensureAC(); board[i]=turn; cells[i].textContent=turn; beep(520,0.07,'square'); if(checkEnd()) return; turn = (turn==='X')?'O':'X'; updateStatus(); if(selOpp.value==='ai' && turn===ai) scheduleAI(); }
      function scheduleAI(){ clearTimeout(aiTimer); aiTimer=setTimeout(aiMove, 1000); }

      function checkWinner(b){ const w=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]; for(const arr of w){ const [a,b1,c]=arr; if(b[a]&&b[a]===b[b1]&&b[a]===b[c]) return arr; } return null; }
      function emptyIdxs(b){ return b.map((v,i)=>v?null:i).filter(v=>v!==null); }
      function finishWith(who, combo){ gameover=true; if(combo) drawLine(combo[0], combo[2]); status.textContent = (selOpp.value==='ai') ? (who===human? '승리!':'패배…') : `${who} 승리!`; beep(900,0.12,'triangle'); beep(1100,0.12,'triangle'); }
      function checkEnd(){ const combo=checkWinner(board); if(combo){ finishWith(board[combo[0]], combo); return true; } if(emptyIdxs(board).length===0){ status.textContent='무승부'; beep(300,0.15,'sawtooth'); gameover=true; return true; } return false; }

      // Minimax
      function minimax(b, player, alpha=-Infinity, beta=Infinity){ const w=checkWinner(b); if(w){ const who=b[w[0]]; return {score: who===ai?1:-1}; } const empties=emptyIdxs(b); if(empties.length===0) return {score:0}; if(player===ai){ let best={score:-Infinity, idx:null}; for(const i of empties){ b[i]=ai; const r=minimax(b,human,alpha,beta); b[i]=''; if(r.score>best.score){best={score:r.score, idx:i};} alpha=Math.max(alpha, r.score); if(beta<=alpha) break; } return best; } else { let best={score:Infinity, idx:null}; for(const i of empties){ b[i]=human; const r=minimax(b,ai,alpha,beta); b[i]=''; if(r.score<best.score){best={score:r.score, idx:i};} beta=Math.min(beta, r.score); if(beta<=alpha) break; } return best; } }
      function aiMove(){ if(gameover||turn!==ai) return; const mv=minimax([...board], ai); const i=mv.idx; if(i==null) return; board[i]=ai; cells[i].textContent=ai; beep(440,0.07,'square'); if(checkEnd()) return; turn=human; updateStatus(); }

      reset.addEventListener('click', init); selOpp.addEventListener('change', init); selFirst.addEventListener('change', init); init();
    })();

    // ===== Omok (AI, 1s delay, win line) =====
    (function(){
      const boardEl=document.getElementById('omok-board');
      const frame=document.getElementById('omok-frame');
      const lineSvg=document.getElementById('omok-line');
      const status=document.getElementById('omok-status');
      const reset=document.getElementById('omok-reset');
      const selOpp=document.getElementById('omok-opponent');
      const selFirst=document.getElementById('omok-first');
      const N=15; let grid, turn='black', gameover=false, human='black', ai='white', aiTimer=null;

      function sizeOverlay(){ const r=frame.getBoundingClientRect(); lineSvg.setAttribute('width', r.width); lineSvg.setAttribute('height', r.height); lineSvg.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`); }
      window.addEventListener('resize', sizeOverlay);
      function clearLine(){ lineSvg.innerHTML=''; }
      function drawLine(from,to){ sizeOverlay(); const c1=centerOf(from.x,from.y), c2=centerOf(to.x,to.y); const line=document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1',c1.x); line.setAttribute('y1',c1.y); line.setAttribute('x2',c2.x); line.setAttribute('y2',c2.y); line.setAttribute('stroke','#4de1c1'); line.setAttribute('stroke-width','6'); line.setAttribute('stroke-linecap','round'); lineSvg.appendChild(line); }
      function centerOf(x,y){ const idx=y*N+x; const el=boardEl.children[idx]; const er=el.getBoundingClientRect(); const fr=frame.getBoundingClientRect(); return { x: er.left - fr.left + er.width/2, y: er.top - fr.top + er.height/2 } }

      function init(){ clearTimeout(aiTimer); lineSvg.innerHTML=''; boardEl.innerHTML=''; grid=Array.from({length:N},()=>Array(N).fill('')); gameover=false; human = selFirst.value; ai = (human==='black')?'white':'black'; turn='black'; status.textContent = (turn===human? '내 차례':'AI 차례');
        for(let y=0;y<N;y++) for(let x=0;x<N;x++){ const cell=document.createElement('div'); cell.className='omok-cell'; cell.addEventListener('click',()=>move(x,y)); boardEl.appendChild(cell); }
        sizeOverlay(); if(selOpp.value==='ai' && human==='white'){ place(Math.floor(N/2),Math.floor(N/2)); scheduleAI(); }
      }

      function place(x,y){ if(gameover||grid[y][x]) return false; grid[y][x]=turn; const idx=y*N+x; const cell=boardEl.children[idx]; const stone=document.createElement('div'); stone.className='stone '+turn; cell.appendChild(stone); beep(turn==='black'?500:420,0.06,'square'); const won=checkWinWithLine(x,y,turn); if(won){ status.textContent=(turn===human? '승리!':'패배…'); gameover=true; drawLine(won.from, won.to); beep(900,0.12,'triangle'); beep(1100,0.12,'triangle'); return true;} turn=(turn==='black')?'white':'black'; status.textContent = (selOpp.value==='ai') ? (turn===human? '내 차례':'AI 차례') : ((turn==='black'?'흑':'백')+' 차례'); return true; }

      function move(x,y){ if(gameover||grid[y][x]) return; if(selOpp.value==='ai' && turn!==human) return; ensureAC(); if(!place(x,y)) return; if(selOpp.value==='ai' && !gameover) scheduleAI(); }
      function scheduleAI(){ clearTimeout(aiTimer); aiTimer=setTimeout(aiMove,1000); }

      function checkWinWithLine(x,y,p){
        function count(dx,dy){ let cells=[{x,y}]; for(let d=1;d<5;d++){ const nx=x+dx*d, ny=y+dy*d; if(nx<0||ny<0||nx>=N||ny>=N||grid[ny][nx]!==p) break; cells.push({x:nx,y:ny}); } for(let d=1;d<5;d++){ const nx=x-dx*d, ny=y-dy*d; if(nx<0||ny<0||nx>=N||ny>=N||grid[ny][nx]!==p) break; cells.unshift({x:nx,y:ny}); } return cells; }
        const dirs=[[1,0],[0,1],[1,1],[1,-1]]; for(const [dx,dy] of dirs){ const seq=count(dx,dy); if(seq.length>=5){ return {from:seq[0], to:seq[seq.length-1]}; } } return null;
      }

      function candidates(){ const cand=new Set(); let any=false; for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(grid[y][x]){ any=true; for(let dy=-2;dy<=2;dy++) for(let dx=-2;dx<=2;dx++){ const nx=x+dx, ny=y+dy; if(nx>=0&&ny>=0&&nx<N&&ny<N&& !grid[ny][nx]) cand.add(ny+','+nx); }} if(!any) cand.add(Math.floor(N/2)+','+Math.floor(N/2)); return Array.from(cand).map(s=>{const [yy,xx]=s.split(',').map(Number); return {x:xx,y:yy};}); }
      function wouldWin(x,y,p){ grid[y][x]=p; const w=checkWinWithLine(x,y,p); grid[y][x]=''; return !!w; }
      function lineScore(x,y,p){ function dir(dx,dy){ let c1=0; for(let d=1;d<5;d++){ const nx=x+dx*d, ny=y+dy*d; if(nx<0||ny<0||nx>=N||ny>=N||grid[ny][nx]!==p) break; c1++; } let c2=0; for(let d=1;d<5;d++){ const nx=x-dx*d, ny=y-dy*d; if(nx<0||ny<0||nx>=N||ny>=N||grid[ny][nx]!==p) break; c2++; } const nx1=x+dx*(c1+1), ny1=y+dy*(c1+1); const open1 = (nx1>=0&&ny1>=0&&nx1<N&&ny1<N&&grid[ny1][nx1]===''); const nx2=x-dx*(c2+1), ny2=y-dy*(c2+1); const open2 = (nx2>=0&&ny2>=0&&nx2<N&&ny2<N&&grid[ny2][nx2]===''); const len=c1+c2+1; let s=len*len; if(open1) s+=1; if(open2) s+=1; if(open1&&open2&&len>=4) s+=6; return s; } return dir(1,0)+dir(0,1)+dir(1,1)+dir(1,-1); }

      function aiMove(){ if(gameover||turn!==ai) return; const cand=candidates(); for(const {x,y} of cand){ if(wouldWin(x,y,ai)) { place(x,y); return; } } for(const {x,y} of cand){ if(wouldWin(x,y,human)) { place(x,y); return; } } let best=null, bestScore=-Infinity; for(const {x,y} of cand){ const s = lineScore(x,y,ai) + 0.9*lineScore(x,y,human); if(s>bestScore){ bestScore=s; best={x,y}; } } if(best) place(best.x,best.y); }

      reset.addEventListener('click', init); selOpp.addEventListener('change', init); selFirst.addEventListener('change', init); init();
    })();
  </script>
</body>
</html>

